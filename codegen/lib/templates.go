// Copyright (c) 2020 Sam Blenny
// SPDX-License-Identifier: Apache-2.0 OR MIT
//
package lib

// Template with usage instructions for the command line tool
const UsageTemplate = `
This tool generates fonts in the form of rust source code.
To confirm that you want to write the files, use the {{.Confirm}} switch.

Font files that will be generated:{{range $f := .Fonts}}
  {{$.OutPath}}/{{$f.RustOut}}{{end}}

Usage:
    go run main.go {{.Confirm}}
`

// Template with rust source code for a outer structure of a font file
const FontFileTemplate = `// DO NOT MAKE EDITS HERE because this file is automatically generated.
// To make changes, see blitstr/codegen/main.go
//
// Copyright (c) 2020 Sam Blenny
// SPDX-License-Identifier: Apache-2.0 OR MIT
//
// NOTE: The copyright notice above applies to the rust source code in this
// file, but not to the bitmap graphics encoded in the DATA array (see credits).
//
// CREDITS:
{{.Font.Legal}}
//! {{.Font.Name}} Font
#![forbid(unsafe_code)]
#![allow(dead_code)]

/// Maximum height of glyph patterns in this bitmap typeface.
/// This will be true: h + y_offset <= MAX_HEIGHT
pub const MAX_HEIGHT: u8 = {{.Font.Size}};

{{.Data}}
`

// Template with rust source code for the data and index portion of a font file
const DataTemplate = `/// Seed for Murmur3 hashes in the HASH_* index arrays
pub const M3_SEED: u32 = {{.M3Seed}};

/// Return Okay(offset into DATA[]) for start of blit pattern for grapheme cluster.
///
/// Before doing an expensive lookup for the whole cluster, this does a pre-filter
/// check to see whether the first character falls into one of the codepoint ranges
/// for Unicode blocks included in this font.
///
/// Returns: Result<(blit pattern offset into DATA, bytes of cluster used by match)>
pub fn get_blit_pattern_offset(cluster: &str) -> Result<(usize, usize), super::GlyphNotFound> {
    let first_char: u32;
    match cluster.chars().next() {
        Some(c) => first_char = c as u32,
        None => return Err(super::GlyphNotFound),
    }
    return match first_char {
        {{ range $_, $k := .GS.IndexKeys -}}
        {{- with $dex := index $.GS.Index $k -}}
        0x{{printf "%X" $k.Low}}..=0x{{printf "%X" $k.High}} => {
            {{ range $_, $gcLen := $dex.ClusterLengthList -}}
            if let Some((offset, bytes_used)) = find_{{ToLower $k.Name}}(cluster, {{$gcLen}}) {
                Ok((offset, bytes_used))
            } else {{ end }}{
                Err(super::GlyphNotFound)
            }
        }
        {{ end -}}
        {{- end -}}
        _ => Err(super::GlyphNotFound),
    };
}

{{ range $_, $k := .GS.IndexKeys -}}
{{- with $dex := index $.GS.Index $k -}}
/// Use binary search on table of grapheme cluster hashes to find blit pattern for grapheme cluster.
/// Only attempt to match grapheme clusters of length limit codepoints.
fn find_{{ToLower $k.Name}}(cluster: &str, limit: u32) -> Option<(usize, usize)> {
    let (key, bytes_hashed) = super::murmur3(cluster, M3_SEED, limit);
    match HASH_{{$k.Name}}.binary_search(&key) {
        Ok(index) => return Some((OFFSET_{{$k.Name}}[index], bytes_hashed)),
        _ => None,
    }
}

/// Index of murmur3(grapheme cluster); sort matches OFFSET_{{$k.Name}}
const HASH_{{$k.Name}}: [u32; {{len $dex}}] = [
    {{$dex.RustCodeForClusterHashes}}
];

/// Lookup table of blit pattern offsets; sort matches HASH_{{$k.Name}}
const OFFSET_{{$k.Name}}: [usize; {{len $dex}}] = [
    {{$dex.RustCodeForOffsets}}
];

{{ end -}}
{{- end -}}

/// Packed glyph pattern data.
/// Record format:
///  [offset+0]: ((w as u8) << 16) | ((h as u8) << 8) | (yOffset as u8)
///  [offset+1..=ceil(w*h/32)]: packed 1-bit pixels; 0=clear, 1=set
/// Pixels are packed in top to bottom, left to right order with MSB of first
/// pixel word containing the top left pixel.
///  w: Width of pattern in pixels
///  h: Height of pattern in pixels
///  yOffset: Vertical offset (pixels downward from top of line) to position
///     glyph pattern properly relative to text baseline
pub const DATA: [u32; {{.GS.DataLen}}] = [
{{.GS.Code}}];`
